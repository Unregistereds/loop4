"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = require("@loopback/metadata");
const binding_filter_1 = require("./binding-filter");
const context_view_1 = require("./context-view");
const resolution_session_1 = require("./resolution-session");
const PARAMETERS_KEY = metadata_1.MetadataAccessor.create('inject:parameters');
const PROPERTIES_KEY = metadata_1.MetadataAccessor.create('inject:properties');
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingSelector What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
function inject(bindingSelector, metadata, resolve) {
    if (typeof bindingSelector === 'function' && !resolve) {
        resolve = resolveValuesByFilter;
    }
    metadata = Object.assign({ decorator: '@inject' }, metadata);
    return function markParameterOrPropertyAsInjected(target, member, methodDescriptorOrParameterIndex) {
        if (typeof methodDescriptorOrParameterIndex === 'number') {
            // The decorator is applied to a method parameter
            // Please note propertyKey is `undefined` for constructor
            const paramDecorator = metadata_1.ParameterDecoratorFactory.createDecorator(PARAMETERS_KEY, {
                target,
                member,
                methodDescriptorOrParameterIndex,
                bindingSelector,
                metadata,
                resolve,
            }, 
            // Do not deep clone the spec as only metadata is mutable and it's
            // shallowly cloned
            { cloneInputSpec: false });
            paramDecorator(target, member, methodDescriptorOrParameterIndex);
        }
        else if (member) {
            // Property or method
            if (target instanceof Function) {
                throw new Error('@inject is not supported for a static property: ' +
                    metadata_1.DecoratorFactory.getTargetName(target, member));
            }
            if (methodDescriptorOrParameterIndex) {
                // Method
                throw new Error('@inject cannot be used on a method: ' +
                    metadata_1.DecoratorFactory.getTargetName(target, member, methodDescriptorOrParameterIndex));
            }
            const propDecorator = metadata_1.PropertyDecoratorFactory.createDecorator(PROPERTIES_KEY, {
                target,
                member,
                methodDescriptorOrParameterIndex,
                bindingSelector,
                metadata,
                resolve,
            }, 
            // Do not deep clone the spec as only metadata is mutable and it's
            // shallowly cloned
            { cloneInputSpec: false });
            propDecorator(target, member);
        }
        else {
            // It won't happen here as `@inject` is not compatible with ClassDecorator
            /* istanbul ignore next */
            throw new Error('@inject can only be used on a property or a method parameter');
        }
    };
}
exports.inject = inject;
var Getter;
(function (Getter) {
    /**
     * Convert a value into a Getter returning that value.
     * @param value
     */
    function fromValue(value) {
        return () => Promise.resolve(value);
    }
    Getter.fromValue = fromValue;
})(Getter = exports.Getter || (exports.Getter = {}));
(function (inject) {
    /**
     * Inject a function for getting the actual bound value.
     *
     * This is useful when implementing Actions, where
     * the action is instantiated for Sequence constructor, but some
     * of action's dependencies become bound only after other actions
     * have been executed by the sequence.
     *
     * See also `Getter<T>`.
     *
     * @param bindingSelector The binding key or filter we want to eventually get
     * value(s) from.
     * @param metadata Optional metadata to help the injection
     */
    inject.getter = function injectGetter(bindingSelector, metadata) {
        metadata = Object.assign({ decorator: '@inject.getter' }, metadata);
        return inject(bindingSelector, metadata, binding_filter_1.isBindingAddress(bindingSelector)
            ? resolveAsGetter
            : resolveAsGetterByFilter);
    };
    /**
     * Inject a function for setting (binding) the given key to a given
     * value. (Only static/constant values are supported, it's not possible
     * to bind a key to a class or a provider.)
     *
     * This is useful e.g. when implementing Actions that are contributing
     * new Elements.
     *
     * See also `Setter<T>`.
     *
     * @param bindingKey The key of the value we want to set.
     * @param metadata Optional metadata to help the injection
     */
    inject.setter = function injectSetter(bindingKey, metadata) {
        metadata = Object.assign({ decorator: '@inject.setter' }, metadata);
        return inject(bindingKey, metadata, resolveAsSetter);
    };
    /**
     * Inject an array of values by a tag pattern string or regexp
     *
     * @example
     * ```ts
     * class AuthenticationManager {
     *   constructor(
     *     @inject.tag('authentication.strategy') public strategies: Strategy[],
     *   ) {}
     * }
     * ```
     * @param bindingTag Tag name, regex or object
     * @param metadata Optional metadata to help the injection
     */
    inject.tag = function injectByTag(bindingTag, metadata) {
        metadata = Object.assign({ decorator: '@inject.tag', tag: bindingTag }, metadata);
        return inject(binding_filter_1.filterByTag(bindingTag), metadata);
    };
    /**
     * Inject matching bound values by the filter function
     *
     * ```ts
     * class MyControllerWithView {
     *   @inject.view(filterByTag('foo'))
     *   view: ContextView<string[]>;
     * }
     * ```
     * @param bindingFilter A binding filter function
     * @param metadata
     */
    inject.view = function injectByFilter(bindingFilter, metadata) {
        metadata = Object.assign({ decorator: '@inject.view' }, metadata);
        return inject(bindingFilter, metadata, resolveAsContextView);
    };
    /**
     * Inject the context object.
     *
     * @example
     * ```ts
     * class MyProvider {
     *  constructor(@inject.context() private ctx: Context) {}
     * }
     * ```
     */
    inject.context = function injectContext() {
        return inject('', { decorator: '@inject.context' }, ctx => ctx);
    };
})(inject = exports.inject || (exports.inject = {}));
function resolveAsGetter(ctx, injection, session) {
    assertTargetIsGetter(injection);
    const bindingSelector = injection.bindingSelector;
    // We need to clone the session for the getter as it will be resolved later
    session = resolution_session_1.ResolutionSession.fork(session);
    return function getter() {
        return ctx.get(bindingSelector, {
            session,
            optional: injection.metadata && injection.metadata.optional,
        });
    };
}
function assertTargetIsGetter(injection) {
    const targetType = inspectTargetType(injection);
    if (targetType && targetType !== Function) {
        const targetName = resolution_session_1.ResolutionSession.describeInjection(injection)
            .targetName;
        throw new Error(`The type of ${targetName} (${targetType.name}) is not a Getter function`);
    }
}
function resolveAsSetter(ctx, injection) {
    const targetType = inspectTargetType(injection);
    const targetName = resolution_session_1.ResolutionSession.describeInjection(injection).targetName;
    if (targetType && targetType !== Function) {
        throw new Error(`The type of ${targetName} (${targetType.name}) is not a Setter function`);
    }
    const bindingSelector = injection.bindingSelector;
    if (!binding_filter_1.isBindingAddress(bindingSelector)) {
        throw new Error(`@inject.setter for (${targetType.name}) does not allow BindingFilter`);
    }
    // No resolution session should be propagated into the setter
    return function setter(value) {
        ctx.bind(bindingSelector).to(value);
    };
}
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param method Method name, undefined for constructor
 */
function describeInjectedArguments(target, method) {
    method = method || '';
    const options = {};
    if (method === '') {
        // A hacky way to check if an explicit constructor exists
        // See https://github.com/strongloop/loopback-next/issues/1565
        if (target.toString().match(/\s+constructor\s*\([^\)]*\)\s+\{/m)) {
            options.ownMetadataOnly = true;
        }
    }
    else if (target.hasOwnProperty(method)) {
        // The method exists in the target, no injections on the super method
        // should be honored
        options.ownMetadataOnly = true;
    }
    const meta = metadata_1.MetadataInspector.getAllParameterMetadata(PARAMETERS_KEY, target, method, options);
    return meta || [];
}
exports.describeInjectedArguments = describeInjectedArguments;
/**
 * Inspect the target type
 * @param injection
 */
function inspectTargetType(injection) {
    let type = metadata_1.MetadataInspector.getDesignTypeForProperty(injection.target, injection.member);
    if (type) {
        return type;
    }
    const designType = metadata_1.MetadataInspector.getDesignTypeForMethod(injection.target, injection.member);
    type =
        designType.parameterTypes[injection.methodDescriptorOrParameterIndex];
    return type;
}
/**
 * Resolve an array of bound values matching the filter function for `@inject`.
 * @param ctx Context object
 * @param injection Injection information
 * @param session Resolution session
 */
function resolveValuesByFilter(ctx, injection, session) {
    assertTargetIsArray(injection);
    const bindingFilter = injection.bindingSelector;
    const view = new context_view_1.ContextView(ctx, bindingFilter);
    return view.resolve(session);
}
function assertTargetIsArray(injection) {
    const targetType = inspectTargetType(injection);
    if (targetType !== Array) {
        const targetName = resolution_session_1.ResolutionSession.describeInjection(injection)
            .targetName;
        throw new Error(`The type of ${targetName} (${targetType.name}) is not Array`);
    }
}
/**
 * Resolve to a getter function that returns an array of bound values matching
 * the filter function for `@inject.getter`.
 *
 * @param ctx Context object
 * @param injection Injection information
 * @param session Resolution session
 */
function resolveAsGetterByFilter(ctx, injection, session) {
    assertTargetIsGetter(injection);
    const bindingFilter = injection.bindingSelector;
    const view = new context_view_1.ContextView(ctx, bindingFilter);
    view.open();
    return view.asGetter(session);
}
/**
 * Resolve to an instance of `ContextView` by the binding filter function
 * for `@inject.view`
 * @param ctx Context object
 * @param injection Injection information
 * @param session Resolution session
 */
function resolveAsContextView(ctx, injection, session) {
    const targetType = inspectTargetType(injection);
    if (targetType && targetType !== context_view_1.ContextView) {
        const targetName = resolution_session_1.ResolutionSession.describeInjection(injection)
            .targetName;
        throw new Error(`The type of ${targetName} (${targetType.name}) is not ContextView`);
    }
    const bindingFilter = injection.bindingSelector;
    const view = new context_view_1.ContextView(ctx, bindingFilter);
    view.open();
    return view;
}
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
function describeInjectedProperties(target) {
    const metadata = metadata_1.MetadataInspector.getAllPropertyMetadata(PROPERTIES_KEY, target) || {};
    return metadata;
}
exports.describeInjectedProperties = describeInjectedProperties;
//# sourceMappingURL=inject.js.map