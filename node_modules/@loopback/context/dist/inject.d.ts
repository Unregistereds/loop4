import { MetadataMap } from '@loopback/metadata';
import { BindingFilter, BindingSelector } from './binding-filter';
import { BindingAddress } from './binding-key';
import { Context } from './context';
import { ResolutionSession } from './resolution-session';
import { BoundValue, ValueOrPromise } from './value-promise';
/**
 * A function to provide resolution of injected values
 */
export interface ResolverFunction {
    (ctx: Context, injection: Readonly<Injection>, session?: ResolutionSession): ValueOrPromise<BoundValue>;
}
/**
 * An object to provide metadata for `@inject`
 */
export interface InjectionMetadata {
    /**
     * Name of the decorator function, such as `@inject` or `@inject.setter`.
     * It's usually set by the decorator implementation.
     */
    decorator?: string;
    /**
     * Control if the dependency is optional, default to false
     */
    optional?: boolean;
    /**
     * Other attributes
     */
    [attribute: string]: BoundValue;
}
/**
 * Descriptor for an injection point
 */
export interface Injection<ValueType = BoundValue> {
    target: Object;
    member?: string;
    methodDescriptorOrParameterIndex?: TypedPropertyDescriptor<ValueType> | number;
    bindingSelector: BindingSelector<ValueType>;
    metadata?: InjectionMetadata;
    resolve?: ResolverFunction;
}
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingSelector What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
export declare function inject(bindingSelector: BindingSelector, metadata?: InjectionMetadata, resolve?: ResolverFunction): (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
/**
 * The function injected by `@inject.getter(bindingSelector)`.
 */
export declare type Getter<T> = () => Promise<T>;
export declare namespace Getter {
    /**
     * Convert a value into a Getter returning that value.
     * @param value
     */
    function fromValue<T>(value: T): Getter<T>;
}
/**
 * The function injected by `@inject.setter(key)`.
 */
export declare type Setter<T> = (value: T) => void;
export declare namespace inject {
    /**
     * Inject a function for getting the actual bound value.
     *
     * This is useful when implementing Actions, where
     * the action is instantiated for Sequence constructor, but some
     * of action's dependencies become bound only after other actions
     * have been executed by the sequence.
     *
     * See also `Getter<T>`.
     *
     * @param bindingSelector The binding key or filter we want to eventually get
     * value(s) from.
     * @param metadata Optional metadata to help the injection
     */
    const getter: (bindingSelector: BindingSelector<unknown>, metadata?: InjectionMetadata | undefined) => (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
    /**
     * Inject a function for setting (binding) the given key to a given
     * value. (Only static/constant values are supported, it's not possible
     * to bind a key to a class or a provider.)
     *
     * This is useful e.g. when implementing Actions that are contributing
     * new Elements.
     *
     * See also `Setter<T>`.
     *
     * @param bindingKey The key of the value we want to set.
     * @param metadata Optional metadata to help the injection
     */
    const setter: (bindingKey: BindingAddress<unknown>, metadata?: InjectionMetadata | undefined) => (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
    /**
     * Inject an array of values by a tag pattern string or regexp
     *
     * @example
     * ```ts
     * class AuthenticationManager {
     *   constructor(
     *     @inject.tag('authentication.strategy') public strategies: Strategy[],
     *   ) {}
     * }
     * ```
     * @param bindingTag Tag name, regex or object
     * @param metadata Optional metadata to help the injection
     */
    const tag: (bindingTag: string | RegExp | import("./value-promise").MapObject<any>, metadata?: InjectionMetadata | undefined) => (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
    /**
     * Inject matching bound values by the filter function
     *
     * ```ts
     * class MyControllerWithView {
     *   @inject.view(filterByTag('foo'))
     *   view: ContextView<string[]>;
     * }
     * ```
     * @param bindingFilter A binding filter function
     * @param metadata
     */
    const view: (bindingFilter: BindingFilter<unknown>, metadata?: InjectionMetadata | undefined) => (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
    /**
     * Inject the context object.
     *
     * @example
     * ```ts
     * class MyProvider {
     *  constructor(@inject.context() private ctx: Context) {}
     * }
     * ```
     */
    const context: () => (target: Object, member: string, methodDescriptorOrParameterIndex?: number | TypedPropertyDescriptor<any> | undefined) => void;
}
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param method Method name, undefined for constructor
 */
export declare function describeInjectedArguments(target: Object, method?: string): Readonly<Injection>[];
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
export declare function describeInjectedProperties(target: Object): MetadataMap<Readonly<Injection>>;
