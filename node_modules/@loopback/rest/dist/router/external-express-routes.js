"use strict";
// Copyright IBM Corp. 2019. All Rights Reserved.
// Node module: @loopback/rest
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const express = require("express");
const HttpErrors = require("http-errors");
const onFinished = require("on-finished");
const util_1 = require("util");
/**
 * A registry of external, Express-style routes. These routes are invoked
 * _after_ no LB4 route (controller or handler based) matched the incoming
 * request.
 *
 * @private
 */
class ExternalExpressRoutes {
    constructor() {
        this._staticRoutes = express.Router();
    }
    registerAssets(path, rootDir, options) {
        this._staticRoutes.use(path, express.static(rootDir, options));
    }
    find(request) {
        return new ExternalRoute(this._staticRoutes, request.method, request.url, {
            description: 'LoopBack static assets route',
            'x-visibility': 'undocumented',
            responses: {},
        });
    }
}
exports.ExternalExpressRoutes = ExternalExpressRoutes;
class ExternalRoute {
    constructor(_staticAssets, verb, path, spec) {
        this._staticAssets = _staticAssets;
        this.verb = verb;
        this.path = path;
        this.spec = spec;
        // ResolvedRoute API
        this.pathParams = [];
        this.schemas = {};
    }
    updateBindings(requestContext) {
        // no-op
    }
    async invokeHandler({ request, response }, args) {
        const handled = await executeRequestHandler(this._staticAssets, request, response);
        if (handled)
            return;
        // Express router called next, which means no route was matched
        throw new HttpErrors.NotFound(`Endpoint "${request.method} ${request.path}" not found.`);
    }
    describe() {
        // TODO(bajtos) provide better description for Express routes with spec
        return `External Express route "${this.verb} ${this.path}"`;
    }
}
const onFinishedAsync = util_1.promisify(onFinished);
/**
 * Execute an Express-style callback-based request handler.
 *
 * @param handler
 * @param request
 * @param response
 * @returns A promise resolved to:
 * - `true` when the request was handled
 * - `false` when the handler called `next()` to proceed to the next
 *    handler (middleware) in the chain.
 */
function executeRequestHandler(handler, request, response) {
    const responseWritten = onFinishedAsync(response).then(() => true);
    const handlerFinished = new Promise((resolve, reject) => {
        handler(request, response, err => {
            if (err) {
                reject(err);
            }
            else {
                // Express router called next, which means no route was matched
                resolve(false);
            }
        });
    });
    return Promise.race([handlerFinished, responseWritten]);
}
//# sourceMappingURL=external-express-routes.js.map